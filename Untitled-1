if (0 < angle && angle < RADIANS_90)
	{
		collision_v->x = floor(player_x / CUBE_SIZE) * CUBE_SIZE +
																	CUBE_SIZE;
		collision_v->y = player_y - ((collision_v->x - player_x) *
											tan(fmod(angle, RADIANS_90))) + 1;
	}
	else if (RADIANS_90 < angle && angle < RADIANS_180)
	{
		collision_v->x = floor(player_x / CUBE_SIZE) * CUBE_SIZE - 1;
		collision_v->y = player_y - ((player_x - collision_v->x) /
											tan(fmod(angle, RADIANS_90))) + 1;
	}
	else if (RADIANS_180 < angle && angle < RADIANS_270)
	{
		collision_v->x = floor(player_x / CUBE_SIZE) * CUBE_SIZE - 1;
		collision_v->y = player_y + ((player_x - collision_v->x) *
											tan(fmod(angle, RADIANS_90)));
	}
	else if (RADIANS_270 < angle && angle < RADIANS_360)
	{
		collision_v->x = floor(player_x / CUBE_SIZE) * CUBE_SIZE +
																	CUBE_SIZE;
		collision_v->y = player_y + ((collision_v->x - player_x) /
											tan(fmod(angle, RADIANS_90)));
	}



    	get_first_intersection_vertical(collision_v, world->player.x, world->player.y, angle);

		(int)(fmod((world.player.y - (sin(fmod(world.player.orientation, RADIANS_90)) * world.player.speed)), CUBE_SIZE))][(int)(fmod((world.player.x + (cos(fmod(world.player.orientation, RADIANS_90)) * world.player.speed)), CUBE_SIZE))
